#pragma once

#include <avr/io.h>
#include "delay_in_cycles.hpp"
#include "type_traits_clone.hpp"


/**
 * Template class used to configure and start the I2S-related clock signals (bit
 * clock and word select). This driver works with 16-bit signed samples, one per
 * channel (left and right).
 *
 * The only two template parameters are:
 * - HALF_BIT_PERIOD, whose name should be self-descriptive, and whose value
 *   must be between 1 (included) and 8 (included);
 * - BUSY_EXTERNAL_CYCLES_BEFORE_FIRST_BUFFER_WRITE, which is the number of
 *   additional CPU cycles between the driver's initialization and the first
 *   time the USART buffer is written (first sendSample() invocation).
 *
 * Most of the driver's configuration revolves around the USART module alone,
 * which takes care of both the actual data and the bit clock signal. This
 * module allows the microcontroller to asynchronously send a stream of bytes,
 * without any pauses or gaps; the only requirement is filling the write buffer
 * with the right timing. The time needed to send one byte (and, thus, the
 * sample rate) is directly tied to HALF_BIT_PERIOD; setting it to 5 (with the
 * CPU clocked at 16 MHz) results in a sample rate of 50 kHz (good for
 * frequencies up to 25 kHz, well beyond the typical human hearing range).
 * Filling the write buffer is much trickier: the buffer is emptied with a
 * specific timing, which is so intricate, a separate function
 * (GET_ADDITIONAL_CYCLES_BEFORE_EARLIEST_BUFFER_WRITE()) was written for
 * handling it.
 *
 * For the word select signal, timer 0 was used. Configuring it is not easier
 * than with the USART module, because of one issue: the timer's output signal
 * needs to be perfectly synchronized with the bitstream generated by the USART
 * module (and I2S' rules on each sample's LSB must be followed as well).
 * This requires knowing exactly when the driver's caller will send each sample
 * (the first one, at the very least), and
 * BUSY_EXTERNAL_CYCLES_BEFORE_FIRST_BUFFER_WRITE (which is configured by the
 * caller) was created for this purpose as well.
 *
 * Additionally, this template provides some constants which represent various
 * clock-related periods (in CPU cycles) and come in handy during cycle counting
 * and generating signals with an accurate frequency.
 */
template<
  uint8_t HALF_BIT_PERIOD,
  uint8_t BUSY_EXTERNAL_CYCLES_BEFORE_FIRST_BUFFER_WRITE,
  enable_if_t<HALF_BIT_PERIOD && HALF_BIT_PERIOD <= 8, int> = 0
>
class I2SDriver {
private:
  /**
   * After writing to UDR0, the USART module waits at least 2 CPU cycles before
   * starting the transmission (probably to update the shift register)
   */
  static constexpr uint8_t USART_BUFFER_DELAY = 2;
  /**
   * The number of CPU cycles required to start timer 0 (basically to run
   * bitSet(TCCR0B, CS00))
   */
  static constexpr uint8_t TIMER_0_ACTIVATION_DELAY = 3;
  /**
   * The number of CPU cycles required for the first instruction of sendSample()
   * (useful for computing the total delay of the first write operation)
   */
  static constexpr uint8_t SEND_SAMPLE_FIRST_WRITE_DELAY = 2;
  static constexpr uint8_t
    BUSY_CYCLES_FROM_USART_INIT_TO_FIRST_BUFFER_WRITE =
    BUSY_EXTERNAL_CYCLES_BEFORE_FIRST_BUFFER_WRITE
    + TIMER_0_ACTIVATION_DELAY;

  /**
   * Given the number of CPU cycles elapsed (in the past or the future),
   * computes how many additional delay cycles are required for starting a
   * buffer write and having the USART module send the written byte as early as
   * possible.
   *
   * Right after being fully initialized (transmitter enabled and UBRR0 set),
   * the user can immediately write a byte on the buffer. However, the byte
   * won't be transmitted right away, and there isn't a fixed delay for this.
   * Instead, the USART module syncs write operations with an internal clock
   * signal. This signal is reflected in the output of the pin XCK during a
   * transmission, and is never stopped or delayed, as long as the module is
   * not deactivated; this is probably intentional, as syncing with a potential
   * receiver is easier with a clock signal whose phase doesn't suddenly change.
   * When sending bytes, each bit is transmitted within a full period of this
   * clock signal, and the exact instants where a new period starts can be
   * deduced according to the following rules:
   * - we assume there were no delays when configuring the USART module (e.g.
   *   no delays between a write to UCSR0B and a write to UBRR0 (more on this
   *   later);
   * - right after setting up USART, the first period starts after UBRR0 + 2
   *   cycles;
   * - each successive period starts 2 * (UBRR0 + 1) cycles after the previous
   *   one.
   * This is the reason for the aforementioned assumption. Right before setting
   * UBRR0 the second time, the internal clock signal is already active (0 is a
   * valid value for UBRR0, which means a clock period of 2 cycles), and its
   * value (high or low) is already changing every CPU cycle; moreover, changes
   * to UBRR0 don't affect the signal's value. It follows that, when the
   * internal counter is updated, the clock signal's value may not be compatible
   * with the expected initial value (as determined by CPOL and CPHA), and the
   * USART module might wait UBRR0 + 1 cycles more. Luckily, if no delays occur
   * when setting up the module, these problems are avoided entirely.
   *
   * There's another aspect to keep in mind when determining the next clock
   * signal period. When the shift register is empty and the buffer is written,
   * the USART module seems to take 2 CPU cycles for setting up the shift
   * register, and only after that it waits for the next clock signal period.
   * E.g. if the buffer is written and the next period starts after 2 cycles,
   * the buffer's first bit will be sent after 2 cycles; however, if the next
   * period starts after 1 cycle, the buffer's first bit will be sent after
   * 2 * (UBRR0 + 1) + 1 cycles (after setting up the shift register, a new
   * period has already started 1 cycle ago, and the USART module must wait for
   * the next period).
   * 
   * Last but not least, we need to keep in mind that writing a byte to the
   * buffer requires at least 2 cycles, depending on the instructions used
   * (usually a single sts).
   */
  static constexpr uint16_t GET_ADDITIONAL_CYCLES_BEFORE_EARLIEST_BUFFER_WRITE(
    const uint16_t elapsedCycles
  ) {
    uint16_t elapsedCyclesPlusWriteDelays =
    elapsedCycles + SEND_SAMPLE_FIRST_WRITE_DELAY + USART_BUFFER_DELAY;
    constexpr uint8_t USART_FIRST_DELAY = HALF_BIT_PERIOD + 1;
    if (elapsedCyclesPlusWriteDelays <= USART_FIRST_DELAY) {
      return USART_FIRST_DELAY - elapsedCyclesPlusWriteDelays;
    } else {
      uint16_t cyclesBeyondFirstUSARTClock =
      elapsedCyclesPlusWriteDelays - USART_FIRST_DELAY - 1;
      uint16_t USARTClockCyclesStarted =
      cyclesBeyondFirstUSARTClock / FULL_BIT_PERIOD + 1;
      return
      USARTClockCyclesStarted
      * FULL_BIT_PERIOD
      + USART_FIRST_DELAY
      - elapsedCyclesPlusWriteDelays;
    }
  }

  static void configureTimer0() {
    constexpr uint8_t TOTAL_CYCLES_FROM_USART_INIT_TO_FIRST_BUFFER_WRITE =
      BUSY_CYCLES_FROM_USART_INIT_TO_FIRST_BUFFER_WRITE
      + OTHER_EXTERNAL_DELAY_CYCLES_BEFORE_FIRST_BUFFER_WRITE;
    constexpr uint8_t TOTAL_CYCLES_FROM_TIMER_INIT_TO_FIRST_BUFFER_WRITE =
      TOTAL_CYCLES_FROM_USART_INIT_TO_FIRST_BUFFER_WRITE
      - TIMER_0_ACTIVATION_DELAY;
    /*
     * We need to remember that, according to the I2S specifications, the word
     * select signal must change before sending the previous byte's LSB; this
     * explains why we subtract FULL_BIT_PERIOD.
     */
    constexpr int16_t CYCLES_FOR_SYNCING_WORD_SELECT_WITH_USART_CLOCK =
      TOTAL_CYCLES_FROM_TIMER_INIT_TO_FIRST_BUFFER_WRITE
      + SEND_SAMPLE_FIRST_WRITE_DELAY
      + USART_BUFFER_DELAY
      - FULL_BIT_PERIOD;
    /*
     * From the moment the timer is activated, it should wait
     * CYCLES_FOR_SYNCING_WORD_SELECT_WITH_USART_CLOCK cycles before its
     * counter resets to 0. Thus, TCNT0 is set to the 2's complement of the
     * above value.
     *
     * An interesting question is whether the output pin will be low when the
     * first sample is written. This is important, because knowing this allows
     * us to reliably send samples to the left and right channel.
     *
     * The counter being reset to 0 doesn't trigger the output pin toggle, only
     * the compare match with OCR0A does. Thus, all we need to know is whether
     * the latter will happen too early, and we can find out by summing
     * CYCLES_FOR_SYNCING_WORD_SELECT_WITH_USART_CLOCK and OCR0A and checking
     * whether the sum is equal to or greater than 256. This could happen if the
     * driver's user spends a lot of cycles before sending the first sample, but
     * this probably won't happen. I'm leaving a static assertion just in case.
     */
    static_assert(
      CYCLES_FOR_SYNCING_WORD_SELECT_WITH_USART_CLOCK + SAMPLE_PERIOD - 1 < 256,
      "The word select signal is not low on the first sample!"
    );

    // Fast PWM (mode 7, continues below), don't start the timer yet
    TCCR0B = bit(WGM02);
    // OC0A toggle mode operation, OC0B normal mode operation, fast PWM (mode 7)
    TCCR0A = bit(COM0A0) | bit(WGM01) | bit(WGM00);
    /*
     * The timer's period matches the sample period.
     * 
     * Also notice that, because SAMPLE_PERIOD = 32 * HALF_BIT_PERIOD and OCR0A
     * is a 8-bit register, SAMPLE_PERIOD can't exceed 256, which translates
     * into HALF_BIT_PERIOD <= 8. This is the reason for the upper limit on
     * HALF_BIT_PERIOD.
     */
    OCR0A = SAMPLE_PERIOD - 1;
    TCNT0 = -CYCLES_FOR_SYNCING_WORD_SELECT_WITH_USART_CLOCK;
  }

  static void configureUSART() {
    // Set UBRR0 to 0 before enabling MSPIM mode
    UBRR0 = 0;
    /*
     * - MSPIM mode;
     * - MSB sent first;
     * - sample first (on rising edge), setup then (on falling edge).
     */
    UCSR0C = bit(UMSEL01) | bit(UMSEL00);
    // Only transmitter enabled.
    UCSR0B = bit(TXEN0);
    /*
     * UBRR0 finally configured; the internal counter should be reset on the
     * next cycle.
     */
    UBRR0 = HALF_BIT_PERIOD - 1;
  }

public:
  /**
   * The number of additional delay cycles the driver's user must wait for
   * before actually invoking sendSample() the first time
   */
  static constexpr uint8_t
    OTHER_EXTERNAL_DELAY_CYCLES_BEFORE_FIRST_BUFFER_WRITE =
    GET_ADDITIONAL_CYCLES_BEFORE_EARLIEST_BUFFER_WRITE(
      BUSY_CYCLES_FROM_USART_INIT_TO_FIRST_BUFFER_WRITE
    );
  /**
   * The number of CPU cycles required by sendSample()
   */
  static constexpr uint8_t SEND_SAMPLE_DURATION = 5;
  /**
   * The number of CPU cycles between two consecutive bits
   */
  static const uint8_t FULL_BIT_PERIOD = HALF_BIT_PERIOD * 2;
  /**
   * The number of CPU cycles between two consecutive audio samples (keep in
   * mind that a sample has to be produced for each channel)
   */
  static const uint16_t SAMPLE_PERIOD = FULL_BIT_PERIOD * 16;
  /**
   * The number of CPU cycles between two consecutive audio frames (a frame
   * consists of a pair of audio samples which will be played at the same time;
   * the first sample is for the left channel and the second one is for the
   * right channel)
   */
  static const uint16_t FRAME_PERIOD = SAMPLE_PERIOD * 2;

  I2SDriver() {
    noInterrupts();
    /*
     * Set pins 6 (timer 0's OC0A), 4 (USART clock) and 1 (USART TX) as outputs;
     * everything else can be left as input.
     */
    DDRD = bit(DDD6) | bit(DDD4) | bit(DDD1);
    configureTimer0();
    configureUSART();
    // Start timer 0 (without prescaler)
    bitSet(TCCR0B, CS00);
  }

  void sendSample(const int16_t sample) {
    UDR0 = int8_t(sample >> 8);
    /*
     * During the 2 cycles delay needed by the USART module after writing UDR0,
     * it seems that a new byte written to UDR0 is ignored. When executing two
     * sts instructions one right after another, the second one is executed 2
     * cycles after the first one, but after some testing this seems not to be
     * enough. Thus, an additional 1-cycle delay was added.
     */
    delayInCyclesWithNOP<1>();
    UDR0 = uint8_t(sample & 0xff);
  }
};
