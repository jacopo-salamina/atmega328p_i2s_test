

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   8:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  10:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  14:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  18:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  1c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  20:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  24:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  28:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  2c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  30:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  34:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  38:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  3c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  40:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  44:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  48:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  4c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  50:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  54:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  58:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  5c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  60:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  64:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61
  74:	0e 94 40 00 	call	0x80	; 0x80 <main>
  78:	0c 94 07 01 	jmp	0x20e	; 0x20e <_exit>

0000007c <__bad_interrupt>:
  7c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000080 <main>:
   * Note that currentPortB was default-initialized on purpose: PORTB's value
   * is retrieved at the very end of the constructor, when the port is already
   * configured.
   */
  I2SDriver() {
    noInterrupts();
  80:	f8 94       	cli
    GTCCR = bit(TSM) | bit(PSRASY) | bit(PSRSYNC);
  82:	83 e8       	ldi	r24, 0x83	; 131
  84:	83 bd       	out	0x23, r24	; 35
private:
  uint8_t currentPortB;
  
  static void configureTimer0() {
    // Fast PWM (mode 7, continues below), prescaler set to 8
    TCCR0B = bit(WGM02) | bit(CS01);
  86:	2a e0       	ldi	r18, 0x0A	; 10
  88:	25 bd       	out	0x25, r18	; 37
    // OC0A toggle mode operation, OC0B normal mode operation, fast PWM (mode 7)
    TCCR0A = bit(COM0A0) | bit(WGM01) | bit(WGM00);
  8a:	93 e4       	ldi	r25, 0x43	; 67
  8c:	94 bd       	out	0x24, r25	; 36
    TCNT0 = 0;
  8e:	16 bc       	out	0x26, r1	; 38
    OCR0A = 0;
  90:	17 bc       	out	0x27, r1	; 39
     * For timer 2 we'll be using a "safe procedure" described in section 17.9
     * for switching to/from asynchronous mode.
     */
    // SAFE PROCEDURE START
    // Disable interrupts.
    TIMSK2 = 0;
  92:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
    // Enable synchronous mode
    bitClear(ASSR, AS2);
  96:	80 91 b6 00 	lds	r24, 0x00B6	; 0x8000b6 <__DATA_REGION_ORIGIN__+0x56>
  9a:	8f 7d       	andi	r24, 0xDF	; 223
  9c:	80 93 b6 00 	sts	0x00B6, r24	; 0x8000b6 <__DATA_REGION_ORIGIN__+0x56>
    // Configure TCNT2, OCR2x and TCCR2x
    // Fast PWM (mode 7, continues below), prescaler set to 8
    TCCR2B = bit(WGM22) | bit(CS21);
  a0:	20 93 b1 00 	sts	0x00B1, r18	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    // OC2A toggle mode operation, OC2B normal operation mode, fast PWM (mode 7)
    TCCR2A = bit(COM2A0) | bit(WGM21) | bit(WGM20);
  a4:	90 93 b0 00 	sts	0x00B0, r25	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    TCNT2 = 0;
  a8:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
    OCR2A = SAMPLE_WIDTH * 2 - 1;
  ac:	87 e1       	ldi	r24, 0x17	; 23
  ae:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    // Clear the interrupt flags
    TIFR2 = 0;
  b2:	17 ba       	out	0x17, r1	; 23
    noInterrupts();
    GTCCR = bit(TSM) | bit(PSRASY) | bit(PSRSYNC);
    configureTimer0();
    configureTimer2();
    // Set pin n. 6 as output (for data clock)
    bitSet(DDRD, DDD6);
  b4:	56 9a       	sbi	0x0a, 6	; 10
    /*
     * Set pin n. 11 and 12 as output; the former is needed for word select
     * clock, while the latter for sending the actual data.
     */
    DDRB |= bit(DDB3) | bit(DDB4);
  b6:	84 b1       	in	r24, 0x04	; 4
  b8:	88 61       	ori	r24, 0x18	; 24
  ba:	84 b9       	out	0x04, r24	; 4
    currentPortB = PORTB;
  bc:	85 b1       	in	r24, 0x05	; 5
   *   tick makes the counter overflow and the output pin toggle).
   * We got lucky: when the word select changes, the bit clock line goes low,
   * as the I2S protocol specifies.
   */
  void start() {
    bitClear(GTCCR, TSM);
  be:	93 b5       	in	r25, 0x23	; 35
  c0:	9f 77       	andi	r25, 0x7F	; 127
  c2:	93 bd       	out	0x23, r25	; 35
	__asm__ volatile (
		"1: dec %0" "\n\t"
		"brne 1b"
		: "=r" (__count)
		: "0" (__count)
	);
  c4:	99 e1       	ldi	r25, 0x19	; 25
  c6:	9a 95       	dec	r25
  c8:	f1 f7       	brne	.-4      	; 0xc6 <main+0x46>
inline void delayInCyclesWithNOP() {
  if (T) {
    delayInCyclesWithNOP<T / 2>();
    delayInCyclesWithNOP<T / 2>();
    if (T % 2) {
      _NOP();
  ca:	00 00       	nop
    uint32_t frequency
  ) :
    amplitude(amplitude),
    ticksIncrement(driver.FRAME_PERIOD * frequency),
    currentAmplitude(0),
    elapsedTicks(0)
  cc:	40 e0       	ldi	r20, 0x00	; 0
  ce:	50 e0       	ldi	r21, 0x00	; 0
  d0:	ba 01       	movw	r22, r20
  delayInCyclesWithLoop<driver.BIT_PERIOD * 5 + 8 - 12>();
  /*
   * Timer 2's counter should read 8 (prescaler 4). Also sample is initialized
   * slightly later.
   */
  uint8_t sample = generator.getFirstSample();
  d2:	90 e0       	ldi	r25, 0x00	; 0
  d4:	24 e0       	ldi	r18, 0x04	; 4
  d6:	f4 e1       	ldi	r31, 0x14	; 20
  d8:	ec e0       	ldi	r30, 0x0C	; 12
  da:	0e c0       	rjmp	.+28     	; 0xf8 <main+0x78>
  dc:	00 00       	nop
  de:	00 00       	nop
  e0:	b7 01       	movw	r22, r14
  e2:	a6 01       	movw	r20, r12
      "cpc %D2, __zero_reg__" "\n\t"
      "brcs .+2" "\n\t"
      "dec %0" "\n\t"
      : "=&r" (nextSample), "=&d" (tmp)
      : "r" (elapsedTicks)
    );
  e4:	99 27       	eor	r25, r25
  e6:	41 15       	cp	r20, r1
  e8:	32 e1       	ldi	r19, 0x12	; 18
  ea:	53 07       	cpc	r21, r19
  ec:	3a e7       	ldi	r19, 0x7A	; 122
  ee:	63 07       	cpc	r22, r19
  f0:	71 05       	cpc	r23, r1
  f2:	08 f0       	brcs	.+2      	; 0xf6 <main+0x76>
  f4:	9a 95       	dec	r25
    return nextSample & amplitude;
  f6:	90 71       	andi	r25, 0x10	; 16
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
  f8:	97 fb       	bst	r25, 7
  fa:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
  fc:	85 b9       	out	0x05, r24	; 5
  fe:	32 2f       	mov	r19, r18
 100:	3a 95       	dec	r19
 102:	f1 f7       	brne	.-4      	; 0x100 <main+0x80>
 104:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 106:	96 fb       	bst	r25, 6
 108:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 10a:	85 b9       	out	0x05, r24	; 5
 10c:	32 2f       	mov	r19, r18
 10e:	3a 95       	dec	r19
 110:	f1 f7       	brne	.-4      	; 0x10e <main+0x8e>
 112:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 114:	95 fb       	bst	r25, 5
 116:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 118:	85 b9       	out	0x05, r24	; 5
 11a:	32 2f       	mov	r19, r18
 11c:	3a 95       	dec	r19
 11e:	f1 f7       	brne	.-4      	; 0x11c <main+0x9c>
 120:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 122:	94 fb       	bst	r25, 4
 124:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 126:	85 b9       	out	0x05, r24	; 5
 128:	32 2f       	mov	r19, r18
 12a:	3a 95       	dec	r19
 12c:	f1 f7       	brne	.-4      	; 0x12a <main+0xaa>
 12e:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 130:	93 fb       	bst	r25, 3
 132:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 134:	85 b9       	out	0x05, r24	; 5
 136:	32 2f       	mov	r19, r18
 138:	3a 95       	dec	r19
 13a:	f1 f7       	brne	.-4      	; 0x138 <main+0xb8>
 13c:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 13e:	92 fb       	bst	r25, 2
 140:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 142:	85 b9       	out	0x05, r24	; 5
 144:	32 2f       	mov	r19, r18
 146:	3a 95       	dec	r19
 148:	f1 f7       	brne	.-4      	; 0x146 <main+0xc6>
 14a:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 14c:	91 fb       	bst	r25, 1
 14e:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 150:	85 b9       	out	0x05, r24	; 5
 152:	32 2f       	mov	r19, r18
 154:	3a 95       	dec	r19
 156:	f1 f7       	brne	.-4      	; 0x154 <main+0xd4>
 158:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 15a:	90 fb       	bst	r25, 0
 15c:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 15e:	85 b9       	out	0x05, r24	; 5
 160:	32 2f       	mov	r19, r18
 162:	3a 95       	dec	r19
 164:	f1 f7       	brne	.-4      	; 0x162 <main+0xe2>
 166:	00 00       	nop
 168:	00 00       	nop
   * thus, the original loop was replaced by a recursive template function.
   */
  void sendSample(const uint8_t sample) {
    sendBitsInAssembly(sample);
    delayInCyclesWithLoop<BIT_PERIOD - 2>();
    bitClear(currentPortB, PORTB4);
 16a:	8f 7e       	andi	r24, 0xEF	; 239
    PORTB = currentPortB;
 16c:	85 b9       	out	0x05, r24	; 5
 16e:	3f 2f       	mov	r19, r31
 170:	3a 95       	dec	r19
 172:	f1 f7       	brne	.-4      	; 0x170 <main+0xf0>
 174:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 176:	97 fb       	bst	r25, 7
 178:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 17a:	85 b9       	out	0x05, r24	; 5
 17c:	32 2f       	mov	r19, r18
 17e:	3a 95       	dec	r19
 180:	f1 f7       	brne	.-4      	; 0x17e <main+0xfe>
 182:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 184:	96 fb       	bst	r25, 6
 186:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 188:	85 b9       	out	0x05, r24	; 5
 18a:	32 2f       	mov	r19, r18
 18c:	3a 95       	dec	r19
 18e:	f1 f7       	brne	.-4      	; 0x18c <main+0x10c>
 190:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 192:	95 fb       	bst	r25, 5
 194:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 196:	85 b9       	out	0x05, r24	; 5
 198:	32 2f       	mov	r19, r18
 19a:	3a 95       	dec	r19
 19c:	f1 f7       	brne	.-4      	; 0x19a <main+0x11a>
 19e:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 1a0:	94 fb       	bst	r25, 4
 1a2:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 1a4:	85 b9       	out	0x05, r24	; 5
 1a6:	32 2f       	mov	r19, r18
 1a8:	3a 95       	dec	r19
 1aa:	f1 f7       	brne	.-4      	; 0x1a8 <main+0x128>
 1ac:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 1ae:	93 fb       	bst	r25, 3
 1b0:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 1b2:	85 b9       	out	0x05, r24	; 5
 1b4:	32 2f       	mov	r19, r18
 1b6:	3a 95       	dec	r19
 1b8:	f1 f7       	brne	.-4      	; 0x1b6 <main+0x136>
 1ba:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 1bc:	92 fb       	bst	r25, 2
 1be:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 1c0:	85 b9       	out	0x05, r24	; 5
 1c2:	32 2f       	mov	r19, r18
 1c4:	3a 95       	dec	r19
 1c6:	f1 f7       	brne	.-4      	; 0x1c4 <main+0x144>
 1c8:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 1ca:	91 fb       	bst	r25, 1
 1cc:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 1ce:	85 b9       	out	0x05, r24	; 5
 1d0:	32 2f       	mov	r19, r18
 1d2:	3a 95       	dec	r19
 1d4:	f1 f7       	brne	.-4      	; 0x1d2 <main+0x152>
 1d6:	00 00       	nop
    asm volatile (
      "bst %1, %3" "\n\t"
      "bld %0, %2" "\n\t"
      : "+r" (destinationByte)
      : "r" (sourceByte), "I" (DESTINATION_BIT), "I" (SOURCE_BIT)
    );
 1d8:	90 fb       	bst	r25, 0
 1da:	84 f9       	bld	r24, 4
  }
  
  template<uint8_t BITS = 7>
  inline void sendBitsInAssembly(const uint8_t sample) {
    copyBitInAssembly<PORTB4, BITS>(currentPortB, sample);
    PORTB = currentPortB;
 1dc:	85 b9       	out	0x05, r24	; 5
 1de:	92 2f       	mov	r25, r18
 1e0:	9a 95       	dec	r25
 1e2:	f1 f7       	brne	.-4      	; 0x1e0 <main+0x160>
 1e4:	00 00       	nop
 1e6:	00 00       	nop
   * thus, the original loop was replaced by a recursive template function.
   */
  void sendSample(const uint8_t sample) {
    sendBitsInAssembly(sample);
    delayInCyclesWithLoop<BIT_PERIOD - 2>();
    bitClear(currentPortB, PORTB4);
 1e8:	8f 7e       	andi	r24, 0xEF	; 239
    PORTB = currentPortB;
 1ea:	85 b9       	out	0x05, r24	; 5
 1ec:	9e 2f       	mov	r25, r30
 1ee:	9a 95       	dec	r25
 1f0:	f1 f7       	brne	.-4      	; 0x1ee <main+0x16e>
 1f2:	00 00       	nop
   * branch and jump at the start of the loop, without the need for an
   * additional rjmp.
   */
  uint8_t getNextSample() {
    elapsedTicks += ticksIncrement;
    int32_t tmp = elapsedTicks - PERIOD_IN_TICKS;
 1f4:	6a 01       	movw	r12, r20
 1f6:	7b 01       	movw	r14, r22
 1f8:	90 e9       	ldi	r25, 0x90	; 144
 1fa:	d9 1a       	sub	r13, r25
 1fc:	91 ef       	ldi	r25, 0xF1	; 241
 1fe:	e9 0a       	sbc	r14, r25
 200:	f1 08       	sbc	r15, r1
    if (tmp >= 0) {
 202:	f7 fe       	sbrs	r15, 7
 204:	6b cf       	rjmp	.-298    	; 0xdc <main+0x5c>
   * infinite loop, and uses the aforementioned jumps both to select the right
   * branch and jump at the start of the loop, without the need for an
   * additional rjmp.
   */
  uint8_t getNextSample() {
    elapsedTicks += ticksIncrement;
 206:	5c 56       	subi	r21, 0x6C	; 108
 208:	6d 4f       	sbci	r22, 0xFD	; 253
 20a:	7f 4f       	sbci	r23, 0xFF	; 255
 20c:	6b cf       	rjmp	.-298    	; 0xe4 <main+0x64>

0000020e <_exit>:
 20e:	f8 94       	cli

00000210 <__stop_program>:
 210:	ff cf       	rjmp	.-2      	; 0x210 <__stop_program>
